# [TIL] 백준 1966번: 프린터 큐로 배운 Python 핵심 요약

**날짜:** 2026-02-01  
**태그:** #Python #Algorithm #Queue #STAR기법 #SSAFY
**문제:** [백준 1966번 - 프린터 큐](https://www.acmicpc.net/problem/1966)

---

## 1. 효율적인 큐 구현을 위한 `deque` 활용

* **Situation (상황):** 문서 인쇄 순서를 정하기 위해 맨 앞 데이터를 꺼내고(`pop`), 필요시 다시 뒤로 넣는(`append`) 작업이 빈번하게 발생함.
* **Task (과제):** 리스트(`list`)의 `pop(0)`은 데이터 이동으로 인해 $O(N)$의 시간이 걸려 성능 저하가 우려됨.
* **Action (행동):** `collections.deque`을 사용해 양방향에서 $O(1)$의 속도로 데이터를 처리함.
    * **예시:** `queue = deque([1, 2, 3])` 상태에서 `popleft()`를 하면 즉시 `1`이 추출되고 `[2, 3]`이 됨.
* **Result (결과):** 대량의 데이터 처리 시에도 '시간 초과' 없이 안정적인 성능을 확보함.





## 2. 자료구조의 상태를 이용한 반복 제어 (`while queue:`)

* **Situation (상황):** 큐에 인쇄할 문서가 남아있는 동안에만 반복문을 실행해야 함.
* **Task (과제):** `while len(queue) > 0:` 처럼 길이를 매번 재는 번거로운 코드 대신 간결한 표현이 필요함.
* **Action (행동):** 파이썬의 **'빈 객체 = False'** 원리를 활용해 `while queue:`를 사용함.
    * **예시:** 식당에 대기 손님이 `[A, B]` 있으면 `True`이므로 계속 서빙하고, 손님이 다 떠나 `[]`가 되면 `False`가 되어 퇴근(종료)하는 것과 같음.
* **Result (결과):** 코드가 가독성이 좋아지고, 큐의 상태 변화에 따라 유연하게 작동하는 루프를 구현함.



## 3. `any()`를 이용한 조건 검사 최적화

* **Situation (상황):** "내 뒤에 나보다 중요한 문서가 단 하나라도 있는가?"를 매번 확인해야 함.
* **Task (과제):** `for`문을 돌려 `flag` 변수를 설정하는 복잡한 로직을 단순화하고 싶음.
* **Action (행동):** `any()` 함수를 사용해 한 줄로 조건을 판별함.
    * **예시:** `any(중요도 > 5 for 중요도 in [1, 3, 9, 2])` -> 리스트 안에 9가 있으므로 즉시 `True` 반환.
* **Result (결과):** "하나라도 존재한다면"이라는 비즈니스 로직을 코드에 직관적으로 반영함.





## 4. 데이터 추출과 순환 로직 (`popleft` & `append`)

* **Situation (상황):** 중요도가 낮아 뒤로 밀려난 문서가 나중에 다시 검사 대상이 되어야 함.
* **Task (과제):** 데이터를 단순히 구경만 하는 게 아니라, 위치를 실제로 옮기는 메커니즘이 필요함.
* **Action (행동):** `popleft()`로 데이터를 꺼냄과 동시에 삭제하고, 조건 만족 시 `append()`로 다시 삽입함.
    * **예시:** `(중요도 1, 인덱스 0)` 문서를 `popleft`로 꺼냈는데 더 큰 문서가 있다면? -> 다시 `append`하여 큐의 맨 뒤로 이동시킴.
* **Result (결과):** 데이터가 사라지지 않고 위치만 바뀌는 '순환 큐' 구조를 완벽히 이해하고 구현함.



## 5. 데이터 식별을 위한 튜플 사용 (`(p, i)`)

* **Situation (상황):** 중요도가 같은 문서가 여러 개 있을 때, 내가 추적 중인 특정 문서(`m`번째)를 구분할 수 없음.
* **Task (과제):** 문서의 순서가 바뀌어도 원래의 위치 정보를 유지해야 함.
* **Action (행동):** `(중요도, 초기 인덱스)` 형태의 **튜플(Tuple)**로 묶어 관리함.
    * **예시:** `[(2, 0), (1, 1), (2, 2)]` -> 0번 문서와 2번 문서는 중요도가 2로 같지만, 인덱스 정보를 통해 서로 다른 문서임을 알 수 있음.
* **Result (결과):** 데이터 이동 중에도 고유 정보가 유실되지 않아 정답을 정확히 도출함.

---

### 💡 최종 핵심 코드 스니펫

```python
from collections import deque

# 1. 이름표 달기: (중요도, 원래 위치)
queue = deque([(p, i) for i, p in enumerate(priorities)])
count = 0

while queue: # 2. 줄에 사람이 있는 동안 반복
    current = queue.popleft() # 3. 일단 한 명 나와서
    
    # 4. 뒤에 나보다 높은 사람이 '하나라도' 있으면?
    if any(current[0] < doc[0] for doc in queue):
        queue.append(current) # 5. 다시 줄 맨 뒤로 가서 서기
    else:
        count += 1 # 6. 내가 대장이라면 인쇄(카운트)
        if current[1] == m: # 7. 근데 그게 내가 찾던 애라면?
            print(count)
            break