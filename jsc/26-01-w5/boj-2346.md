# [Algorithm] 백준 2346번: 풍선 터뜨리기 (완전 정복)

## 📌 1. 초기 접근 방식과 문제점 (Troubleshooting)

### **S (Situation - 상황)**
* 처음에는 `deque`를 사용하되, `popleft(count)` 처럼 인덱스를 직접 지정해서 터뜨리거나 `count` 변수로 인덱스를 직접 계산하려 함.

### **T (Task - 과제)**
* `deque`의 특성을 살리면서 원형 큐처럼 데이터를 처리해야 함.

### **A (Action - 시도했던 코드의 문제점)**
```python
# ❌ 문제점 발견
# 1. q.popleft(count): popleft는 인자를 받지 않음 (무조건 맨 앞 삭제).
# 2. deque = deque(...): 변수명을 클래스명과 똑같이 쓰면 나중에 기능 사용 불가.
# 3. count += k: 인덱스를 직접 계산하면 음수 처리와 리스트 크기 변화 처리가 매우 복잡함.

```

### **R (Result - 해결책)**

* 인덱스를 계산해서 찾아가는 방식이 아니라, **`rotate` 함수를 써서 터뜨릴 풍선을 맨 앞으로 가져오는 방식**으로 변경.

---

## 🚀 2. 해결법: Deque와 Rotate 활용 (STAR 분석)

이 방식은 데이터를 직접 회전시켜 타겟을 `popleft()` 위치(맨 앞)로 가져오는 방식입니다.

### **S (Situation)**

* 풍선이 터지면 전체 리스트 길이가 줄어들고, 원형으로 연결되어 있어 인덱스 처리가 까다로움.

### **T (Task)**

* 복잡한 인덱스 나머지 연산(%) 없이 직관적으로 다음 풍선을 찾아야 함.

### **A (Action)**

* `collections.deque`의 **`rotate()`** 활용.
* **핵심 로직 (Why `k-1`?):**
* ** (양수):** `rotate(-(k - 1))`
* 풍선을 터뜨리는(`popleft`) 순간, 뒤에 있던 친구들이 자동으로 한 칸씩 앞으로 당겨짐.
* 이미 1칸 이동한 효과가 나므로, 실제 이동 값 에서 을 뺀 만큼만 더 왼쪽으로 회전시킴.


* ** (음수):** `rotate(-k)`
* 오른쪽으로 이동할 때는 내 위치 변화가 다음 타겟(뒤쪽)에 영향을 주지 않으므로 그대로 회전.





### **R (Result)**

* 시간 복잡도가 효율적이며 코드가 매우 간결해짐.

### **💡 Code Detail (질문 모음)**

#### **Q1. `idx, k = q.popleft()` 이게 무슨 문법인가요?**

* **Tuple Unpacking (튜플 언패킹):**
* `q` 안에 `(1, 3)` 같은 튜플이 들어있을 때, 값을 꺼내면서 동시에 변수 `idx`(1)와 `k`(3)에 나누어 담는 파이썬 문법.
* 코드를 직관적으로 만들어 줌.



#### **Q2. `while q:` 안에 `if not q: break`는 왜 필요한가요?**

* 마지막 풍선을 `popleft()` 하고 나면 `q`는 빈 상태가 됨.
* 빈 덱을 `rotate` 하려고 하면 논리적 오류(혹은 불필요한 연산)가 발생.
* 따라서 마지막 풍선을 터뜨린 직후에는 **회전 없이 즉시 종료**하기 위해 안전장치로 넣음.

#### **Q3. `if` 대신 `elif`를 써야 하지 않나요?**

* `if not q: break`가 있어서 논리적으로는 `if`를 또 써도 문제없지만, **가독성과 구조적 명확성**을 위해 `elif`를 쓰는 것이 Best Practice!

```python
from collections import deque
import sys
input = sys.stdin.readline

n = int(input())
# enumerate로 (번지수, 이동값) 튜플 생성
q = deque(enumerate(map(int, input().split()), start=1))
res = []

while q:
    idx, k = q.popleft() # 언패킹
    res.append(idx)
    
    if not q: break # 마지막 풍선이면 종료
    
    # 이동 로직
    if k > 0:
        q.rotate(-(k - 1)) # 왼쪽 회전 (보정 -1)
    else:
        q.rotate(-k)       # 오른쪽 회전

print(*(res))

```

---

## 🧮 3. 다른 접근: 리스트와 인덱스 계산 (STAR 분석)

`deque`를 쓰지 않고, 수학적으로 "다음 인덱스"를 계산해서 `pop`하는 방식입니다.

### **S (Situation)**

* `rotate` 함수 없이 순수 리스트 기능만으로 구현하고 싶음.

### **T (Task)**

* 리스트 길이가 계속 줄어드는 상황에서, 원형으로 연결된 다음 인덱스를 정확히 계산해야 함.

### **A (Action)**

* **나머지 연산(%)** 활용.
* `current_idx = (current_idx + (k - 1)) % len(balloons)` 공식을 사용하여 인덱스 오버플로우 방지.
* 리스트의 `pop(index)` 사용.

### **R (Result)**

* "내가 지금 몇 번째 인덱스에 있는지" 명확히 알 수 있음.
* 단, `pop(index)`는 뒤의 요소들을 당기는 연산 때문에 속도가 느림 ().

```python
n = int(input())
balloons = list(enumerate(map(int, input().split()), start=1))
res = []
current_idx = 0

while balloons:
    idx, k = balloons.pop(current_idx)
    res.append(idx)
    
    if not balloons: break
    
    # 다음 인덱스 계산 (나머지 연산 활용)
    if k > 0:
        current_idx = (current_idx + (k - 1)) % len(balloons)
    else:
        current_idx = (current_idx + k) % len(balloons)

print(*(res))

```

---

## 📝 4. 핵심 요약 (Key Takeaways)

| 구분 | Deque (`rotate`) | List (`pop(idx)`) |
| --- | --- | --- |
| **개념** | 데이터를 **직접 움직여서** 내 앞으로 가져옴 | 데이터는 두고 **인덱스를 계산**해서 찾아감 |
| **특징** | `k > 0`일 때 `k-1` 보정 필요 | 나머지 연산(%)으로 원형 구조 구현 |
| **성능** | 삽입/삭제가 빈번할 때 유리 () | 중간 삭제 시 데이터 밀림 발생 () |
| **추천** | **알고리즘 문제 풀이용 (속도 빠름)** | **구현 논리 연습용** |
